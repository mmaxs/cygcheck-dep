#! /bin/bash
#
# cygcheck-dep
# Copyright (c) 2013-2018 Mikhail Usenko <mikeus@nm.ru>
# GNU General Public License
#
# https://github.com/mmaxs/cygcheck-dep
#


### DECLARATIONS

name="cygcheck-dep"
version="3.0"

## version(), help() /*

version()
{
  echo "$name, version $version"
}

help()
{
  version
  cat << $
Show information on dependencies for installed Cygwin packages.

Usage:
  $name [-c] [-s FILE | -S] [:setup diagnostics switches:]
  $name [-c] [-s FILE | -S] [:package information switches:]
  $name [-h | --help]
  $name [-V | --version]

Setup diagnostics switches:
  -l              Check for installed packages that are not required by any
                  other installed packages (that are "leaves" in the package
                  dependency tree). Unless the -O option is specified, this
                  list also includes obsolete installed packages for which
                  the corresponding replacing packages are installed.

  -i              Check for package "islands". "An island" is a group of
                  interdependent packages that require each other (with
                  circular or all-to-all dependencies), but being taken
                  all together not needed for any other installed packages.

  -I              Show all groups of interdependent packages with circular
                  or all-to-all dependencies (including groups that are
                  not "islands"). Supersedes -i switch.

  -b              Show installed packages that have broken or unknown
                  dependencies along with lists of missing required packages
                  for them (which might include not only available but for
                  some reason not installed dependecies, but also merely
                  unknown package names).

  -m              Show missing required dependencies and installed packages
                  for which they are required.

  -o              Show installed packages that are obsoleted by available
                  replacing package.

  -x              Show extraneous installed packages that are not present in
                  Cygwin standard distribution whose dependencies can not
                  therefore be figured out from <setup.ini> file.

  -C              Check for available updates for installed packages.
                  Ignores -c.

Package information switches:
  -r PACKAGE...   Show the list of packages that are required by the installed
                  PACKAGE.

  -R PACKAGE...   Recursively resolve the list of packages that are required
                  by the installed PACKAGE.

  -n PACKAGE...   Show the list of packages that need the installed PACKAGE.

  -N PACKAGE...   Recursively resolve the list of packages that need the
                  installed PACKAGE.

  -d PACKAGE...   Show the list of packages that will become not required by
                  any other installed packages (i.e. will become "leaves"),
                  if the PACKAGE is uninstalled. Thus, these packages,
                  if being unnecessary, can be selected for uninstalling
                  in <setup.exe> together with the PACKAGE.

  -D PACKAGE...   The recursive version of -d switch.

Run mode options:
  -c              Normally every time $name runs, it downloads latest
                  Cygwin package database file <setup.ini> with information
                  on package dependencies from Cygwin's ftp site. This option
                  prevents from unnecessary downloads and forces to use the
                  file cached at the previous run.

  -s FILE         Normally $name shows information on the installed
                  packages for the Cygwin installation you are working in (the
                  list of installed packages is /etc/setup/installed.db).
                  With this option you can specify a different database FILE
                  of the installed packages (e.g. the file from another Cygwin
                  installation on your system).

<setup.ini> file diagnostics switches:
  -S              Instead of checking through only installed packages, check
                  through the list of all available packages from <setup.ini>
                  file. In other words, all the available packages from the
                  package database (excluding packages from the category
                  '_obsolete', unless the -O option is specified) will be
                  treated as if they where installed. Supersedes -s option.

  -O              Respect obsoleted packages when processing -S switch:
                  treat obsoleted packages as having been also installed
                  (so this will affect on all setup diagnostics and package
                  information switches).
                  -b (When -O option is specified, the list of missing required packages might also contain obsoleted packages.)
                  -r (With -O option this is the very same list that
                  specified in "requires:" line in <setup.ini> file for the
                  PACKAGE. If no -O option is specified, this is the list of
                  packages that <setup.exe> would install along with the
                  PACKAGE as its required dependencies.)
                  -n (Without -O option being specified, obsoleted packages are considered as being not needed for anyone, so resulting in  an empty list.)

Output modifiers:
  -p              While printing package names prefix them with status marks.
                  Status marks are:
                    ?? - unknown package name,
                    ?  - extraneous installed package,
                    &  - obselete installed package,
                    !  - installed package with broken dependencies,
                    *  - not installed package (e.g. broken dependency);
                  (! and & marks might be juxtaposed).

  -q              Be more quiet: suppress any advance warnings.

  -v              Be more verbose: turn on Wget's output to /dev/stderr while
                  downloading <setup.ini> file.

Other switches:
  -h, --help      Print this help and exit.
  -V, --version   Print the program version and exit.
$
}
## */

## global variables /*

# ${PkgID[$name]}
#     - associative array to be used as a map (package $name) -> (package $id)
# ${PkgName[$id]}
#     - indexed array for the reverse map (package $id) -> (package $name)
#
# the above arrays serve as a global catalogue of all package names encountered
# while processing entries read form <setup.ini> and <installed.db> files
#
# $MaxPkgID
#     - track the current maximum package ID,
#       it is always = ${#PkgID[*]} = ${#PkgName[*]}
declare -A PkgID
declare -a PkgName
declare -i MaxPkgID=0

# ${PkgCategories[$id]}
#     - indexed array, the list of categories which the package $id belongs to
declare -a PkgCategories

# ${PkgVersionAvailable[$id]}
#     - indexed array, the version of the package $id from <setup.ini> file
declare -a PkgVersionAvailable PkgVersionInstalled

# ${PkgRequisites[$id]}
#     - indexed array, array element is a $'\n'-dlimited list of package IDs
#       that are directly required by the package $id
# ${PkgRequisites_R[$id]}
#     - indexed array, array element is a recursively resolved $'\n'-dlimited list
#       of package IDs that are directly and indirectly required by the package $id
declare -a PkgRequisitesDeclared PkgRequisites PkgRequisites_R
declare -a  PkgBrokenRequisites MissingPkgs

# ${PkgObsoletedPkgs[$id]}
declare -a PkgObsoletedPkgs

# ${PkgDependants[$id]}
#     - indexed array, array element is a $'\n'-dlimited list of package IDs
#       that directly depend on the package $id
# ${PkgDependants_R[$id]}
#     - indexed array, array element is a recursively resolved $'\n'-dlimited list
#       of package IDs that directly and indirectly depend on the package $id
declare -a PkgDependants PkgDependants_R

# ${InstalledPkgs[$id]}
#     - indexed array to be used as a set of all installed package IDs, InstalledPkgs[$id] = $name
# ${ExtraneousPkgs[$id]}
#     - indexed array to store extraneous installed package IDs, ExtraneousPkgs[$id] = $name
declare -a InstalledPkgs ExtraneousPkgs

# ${ObsoletePkgs[$id]}
#     - indexed array to store IDs of obsolete packages, ObsoletePkgs[$id] = (replacing package IDs)
declare -a ObsoletePkgs

# ${UnknownPkgs[$id]}
#     - indexed array to store packages ID that have unknown names,
#       UnknownPkgs[$id] = (where the unknown name has appeared)
declare -a UnknownPkgs

## */

## __squeeze(), __prepare_list(), __find_in_list() /*

# [in/out]  $1 - reference (variable name) to string
# [opt]     $2 - char for squeezing, default to $'\n'
__squeeze()
{
  local -n string_="$1"
#  local c="${2:-$'\n'}" t="$string_"
#  string_="${t//$c$c/$c}"
#  while [ "$string_" != "$t" ]; do
#    t="$string_"
#    string_="${t//$c$c/$c}"
#  done
  eval "
    local c$1=\"\${2:-\$'\n'}\" t$1=\"\$string_\"
    string_=\"\${t$1//\${c$1}\${c$1}/\${c$1}}\"
    while [ \"\$string_\" != \"\${t$1}\" ]; do
      t$1=\"\$string_\"
      string_=\"\${t$1//\${c$1}\${c$1}/\${c$1}}\"
    done
  "
}

# [in/out]  $1 - reference (variable name) to resulting list
# [in]      $2 - string with source list
# [opt]     $3 - source list delimiter, a space by default
__prepare_list()
{
  local -n list_="$1"
#  local t="${2//${3:- }/$'\n'}"
#  [ "$t" = "$list_" ] && return
#  t="${t// }"
#  __squeeze t
#  t="${t#$'\n'}"
#  t="${t%$'\n'}"
#  list_="$t"
  eval "
    local t$1=\"\${2//\${3:- }/\$'\n'}\"
    [ \"\${t$1}\" = \"\$list_\" ] && return
    t$1=\"\${t$1// }\"
    __squeeze t$1
    t$1=\"\${t$1#\$'\n'}\"
    t$1=\"\${t$1%\$'\n'}\"
    list_=\"\${t$1}\"
  "
}

# [in]  $1 - string with the list to be searched
# [in]  $2 - sought item
# [opt] $3 - list delimiter, default to $'\n'
__find_in_list()
{
  local d="${3:-$'\n'}"
  [[ "$1" =~ (^|"$d")"$2"("$d"|$) ]]
}

## */

## nout() /*
nout()
{
  local id m=''
  local -a p

  for id in $*; do p["$id"]="$id"; done

  for id in "${!p[@]}"; do
    if [ "$opt_use_prefix" ]; then
      m=''
      if [ "${UnknownPkgs[$id]}" ]; then
        m+='??'
      elif [ "${InstalledPkgs[$id]}" ]; then
        if [ "${ExtraneousPkgs[$id]}" ]; then
          m+='?'
        else
          [ "${PkgBrokenRequisites[$id]}" ] && m+='!'
          [ "${ObsoletePkgs[$id]}" ] && m+='&'
        fi
      else
        m+='*'
      fi
    fi
    echo -n " $m${PkgName[$id]}"
  done
}
## */

## add_new_package_to_catalogue() /*
add_new_package_to_catalogue()
{
  let ++MaxPkgID
  PkgID["$1"]="$MaxPkgID"
  PkgName[$MaxPkgID]="$1"
}
## */

## resolve_package_name_list() /*
# [in/out]  $1 - reference (variable name) to resulting list of package IDs
# [in]      $2 - string with ${IFS}-delimited source list of package names
# [opt]     $3 - source list description
# [side]    add unknown package names to the catalogue and to ${UnknownPkgs[$id]}
resolve_package_name_list()
{
  local -n list_="$1"
  list_=''
#  local name id
#  for name in $2; do
#    id="${PkgID[$name]}"
#    if ! [ "$id" ]; then
#      add_new_package_to_catalogue "$name"
#      UnknownPkgs[$MaxPkgID]="${3:-$name}"
#      id="$MaxPkgID"
#    fi
#    list_+=$'\n'"$id"
#  done
  eval "
    local name$1 id$1
    for name$1 in \$2; do
      id$1=\"\${PkgID[\${name$1}]}\"
      if ! [ \"\${id$1}\" ]; then
        add_new_package_to_catalogue \"\${name$1}\"
        UnknownPkgs[\$MaxPkgID]=\"\${3:-\${name$1}}\"
        id$1=\"\$MaxPkgID\"
      fi
      list_+=\$'\n'\"\${id$1}\"
    done
  "
  list_="${list_#$'\n'}"
}
## */

## is_all_installed(), filter_not_installed() /*
is_all_installed()
{
  local id
  for id in $*; do
    [ "${InstalledPkgs[$id]}" ] || return 1
  done
  return 0
}

filter_not_installed()
{
  local -n list_="$1"
  list_=''
#  local id
#  for id in ${*:2}; do
#    [ "${InstalledPkgs[$id]}" ] || list_=$'\n'"$id"
#  done
  eval "
    local id$1
    for id$1 in \${*:2}; do
      [ \"\${InstalledPkgs[\${id$1}]}\" ] || list_=\$'\n'\"\${id$1}\"
    done
  "
  list_="${list_#$'\n'}"
}
## */

## resolve_PkgRequisites_R(), resolve_PkgDependants_R() /*
resolve_PkgRequisites_R()
{
  :
}

resolve_PkgDependants_R()
{
  :
}
## */


### SCRIPT

## parse command-line options /*
cmd_show_leaves=''
cmd_show_islands=''
cmd_show_interdependent=''
cmd_show_broken=''
cmd_show_missing=''
cmd_show_unknown=''
cmd_show_obsoleted=''
cmd_show_extraneous=''
cmd_show_updates=''
cmd_show_required=''
cmd_show_required_recurisive=''
cmd_show_dependent=''
cmd_show_dependent_recursive=''
cmd_show_new_leaves=''
cmd_show_new_leaves_recursive=''
cmds=''
opt_use_cached_setup_ini=''
opt_use_custom_installed_db=''
opt_treat_setup_ini_as_installed=''
opt_respect_obsoleted=''
opt_use_prefix=''
opt_be_more_quiet=''
opt_be_more_verbose=''

while getopts "liIbmMoxCrRnNdDcs:SOpqv-:hV" OPT; do
  case "$OPT" in
    l)  cmd_show_leaves="{cmd_show_leaves}"
        ;;
    i)  cmd_show_islands="{cmd_show_islands}"
        ;;
    I)  cmd_show_interdependent="{cmd_show_interdependent}"
        ;;
    b)  cmd_show_broken="{cmd_show_broken}"
        ;;
    m)  cmd_show_missing="{cmd_show_missing}"
        ;;
    M)  cmd_show_unknown="{cmd_show_unknown}"
        ;;
    o)  cmd_show_obsoleted="{cmd_show_obsoleted}"
        ;;
    x)  cmd_show_extraneous="{cmd_show_extraneous}"
        ;;
    C)  cmd_show_updates="{cmd_show_updates}"
        ;;
    r)  cmd_show_required="{cmd_show_required}"
        ;;
    R)  cmd_show_required_recurisive="{cmd_show_required_recurisive}"
        ;;
    n)  cmd_show_dependent="{cmd_show_dependent}"
        ;;
    N)  cmd_show_dependent_recursive="{cmd_show_dependent_recursive}"
        ;;
    d)  cmd_show_new_leaves="{cmd_show_new_leaves}"
        ;;
    D)  cmd_show_new_leaves_recursive="{cmd_show_new_leaves_recursive}"
        ;;
    c)  opt_use_cached_setup_ini="yes"
        ;;
    s)  opt_use_custom_installed_db="$OPTARG"
        ;;
    S)  opt_treat_setup_ini_as_installed="yes"
        ;;
    O)  opt_respect_obsoleted="yes"
        ;;
    p)  opt_use_prefix="yes"
        ;;
    q)  opt_be_more_quiet="yes"
        ;;
    v)  opt_be_more_verbose="yes"
        ;;
    -)  case "$OPTARG" in
             help)  help
                    exit 0
                    ;;
          version)  version
                    exit 0
                    ;;
                *)  echo >&2 "$0: illegal option -- -$OPTARG"
                    exit 1;
                    ;;
        esac
        ;;
    h)  help
        exit 0
        ;;
    V)  version
        exit 0;
        ;;
   \?)  exit 1
        ;;
  esac
done
eval cmds=\""$(IFS='$'; echo "\$${!cmd_*}")"\"
## */

[ "$cmds" ] || exit

## check for the cache directory /*
cache_dir="/var/cache/$name"
[ -d "$cache_dir" ] ||
if ! mkdir -p "$cache_dir"; then
  echo >&2 "$0: unable to create cache directory:"
  echo >&2 "$0:   $cache_dir"
  exit 2
fi
## */

## check for the <installed.db> file /*
installed_db="${opt_use_custom_installed_db:-/etc/setup/installed.db}"
[ "$opt_treat_setup_ini_as_installed" ] ||
if ! [ -r "$installed_db" ]; then
  echo >&2 "$0: <installed.db> file is not exist or is not readable:"
  echo >&2 "$0:   $installed_db"
  exit 3
fi
## */

## identify the host architecture /*
# mach="$(uname -m)"
mach="${MACHTYPE%%-*}"
[ "$mach" = "x86_64" ] || mach="x86"
## */

## download <setup.ini> file /*
cw_setup_ini="$cache_dir/cygwin/$mach/setup.ini"
if ! [ "$opt_use_cached_setup_ini" ] || [ "$cmd_show_updates" ]; then
  cw_setup_bz2_url="ftp://sourceware.org/pub/cygwin/$mach/setup.bz2"
  [ "$opt_be_more_verbose" ] && opt_wget_verbosity="-nv" || opt_wget_verbosity="-q"
  if ! wget >&2 "$opt_wget_verbosity" -r -nH --cut-dirs 1 -P "$cache_dir" "$cw_setup_bz2_url"; then
    echo >&2 "$0: failed to download <setup.ini> file:"
    echo >&2 "$0:   $cw_setup_bz2_url"
    echo >&2 "$0: you may try to run with -c option to use cached file from previous download"
    exit 4
  fi
  cw_setup_bz2="$cache_dir/cygwin/$mach/setup.bz2"
  if ! bzip2 -t "$cw_setup_bz2"; then
    echo >&2 "$0: failed to check integrity of downloaded <setup.ini> file:"
    echo >&2 "$0:   $cw_setup_bz2"
    echo >&2 "$0: you may try to run with -c option to use cached file from previous download"
    exit 5
  fi
  if ! bzcat "$cw_setup_bz2" > "$cw_setup_ini"; then
    echo >&2 "$0: failed to decompress downloaded <setup.ini> file:"
    echo >&2 "$0:   $cw_setup_bz2"
    exit 6
  fi
fi

if ! [ -r "$cw_setup_ini" ]; then
  echo >&2 "$0: <setup.ini> file is not exist or is not readable:"
  echo >&2 "$0:   $cw_setup_ini"
  [ "$opt_use_cached_setup_ini" ] &&
  echo >&2 "$0: you may try to run without -c option to download the file"
  exit 7
fi
## */

# $L $P $C $R $V $O $D $T - temporary variables
L=''; P=''; C=''; R=''; V=''; O=''; D=''; T=''

## read and parse <setup.ini> file; populate ${PkgID[]}, ${PkgName[]}, et al. /*
#L="$(sed -n '
#    :begin
#    /^@\s\+\(\S\+\)\s*$/{s//add_new_package_to_catalogue "\1"/p; b}
#    /^category:\s\+\(_obsolete\)\s*$/{s//PkgCategories[$MaxPkgID]="\1"; D="obsolete package"/p; b}
#    /^category:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//__prepare_list C "\1"; PkgCategories[$MaxPkgID]="$C"; D=''/p; b}
#    /^requires:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//__prepare_list R "\1"; PkgRequisitesDeclared[$MaxPkgID]="$R"/p; b}
#    /^version:\s\+\(\S\+\)\s*$/{s//PkgVersionAvailable[$MaxPkgID]="\1"/p; b}
#    /^obsoletes:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//__prepare_list O "\1" ","; PkgObsoletedPkgs[$MaxPkgID]="$O"/p; b}
#    /^depends2:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//[ "$D" ] \&\& { __prepare_list D "\1" ","; ObsoletePkgs[$MaxPkgID]="$D"; }/p; b}
#    /^\[prev\]/{:skip-prev n; /^@/b begin; b skip-prev}
#    /^\[test\]/{:skip-test n; /^@/b begin; b skip-test}
#' "$cw_setup_ini")"
L="$(sed -n '
    :begin
    /^@\s\+\(\S\+\)\s*$/{s//add_new_package_to_catalogue "\1"/p; b}
    /^category:\s\+\(_obsolete\)\s*$/{s//PkgCategories[$MaxPkgID]="\1"; T="obsolete package"/p; b}
    /^category:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//__prepare_list C "\1"; PkgCategories[$MaxPkgID]="$C"; T=''/p; b}
    /^version:\s\+\(\S\+\)\s*$/{s//PkgVersionAvailable[$MaxPkgID]="\1"/p; b}
    /^obsoletes:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//__prepare_list O "\1" ","; PkgObsoletedPkgs[$MaxPkgID]="$O"/p; b}
    /^requires:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//[ "$T" ] \&\& { __prepare_list R "\1"; PkgRequisitesDeclared[$MaxPkgID]="$R"; }/p; b}
    /^depends2:\s\+\(\S\+\(\s\+\S\+\)*\)\s*$/{s//__prepare_list R "\1" ","; [ "$T" ] \&\& ObsoletePkgs[$MaxPkgID]="$R" || PkgRequisitesDeclared[$MaxPkgID]="$R"/p; b}
    /^\[prev\]/{:skip-prev n; /^@/b begin; b skip-prev}
    /^\[test\]/{:skip-test n; /^@/b begin; b skip-test}
' "$cw_setup_ini")"
eval "$L"
L=''

## check the results of reading/parsing <setup.ini> file /*
if [ "$(sed -n '/^@ /p' "$cw_setup_ini" | wc -l)" != "$MaxPkgID" ]; then
  echo >&2 "$0: failed to parse data from <setup.ini> file:"
  exit 8
fi
if [ "${#PkgCategories[@]}" != "${#PkgName[@]}" ] && ! [ "$opt_be_more_quiet" ]; then
  echo >&2    "# $0:"
  echo >&2    "# warning: not available package category:"
  echo >&2    "#   failed to parse <setup.ini> file record of"
  echo >&2    "#   'category:' for the following packages:"
  echo >&2 -n "#("
  for id in "${!PkgName[@]}"; do [ "${PkgCategories[$id]}" ] || echo >&2 -n " ${PkgName[$id]}"; done
  echo >&2    " )"
  echo >&2
fi
if [ "${#PkgVersionAvailable[@]}" != "${#PkgName[@]}" ] && ! [ "$opt_be_more_quiet" ]; then
  echo >&2    "# $0:"
  echo >&2    "# warning: not available package version:"
  echo >&2    "#   failed to parse <setup.ini> file record of"
  echo >&2    "#   'version:' for the following packages:"
  echo >&2 -n "#("
  for id in "${!PkgName[@]}"; do [ "${PkgVersionAvailable[$id]}" ] || echo >&2 -n " ${PkgName[$id]}"; done
  echo >&2    " )"
  echo >&2
fi
## */
## */

echo $MaxPkgID

if [ "$opt_treat_setup_ini_as_installed" ]; then
## populate ${InstalledPkgs[]} using data from ${PkgName[]} /*
  L="${PkgName[@]@A}"
  L="${L/ PkgName=/ InstalledPkgs=}"
  eval "$L"

  L="${PkgVersionAvailable[@]@A}"
  L="${L/ PkgVersionAvailable=/ PkgVersionInstalled=}"
  eval "$L"
  L=''

  if [ "${#InstalledPkgs[@]}" -ne "$MaxPkgID" ] || [ "${InstalledPkgs[0]+index is set}" ]; then
    echo >&2 "$0: internal error (9)"
    exit 9
  fi

  [ "$opt_respect_obsoleted" ] ||
  for id in "${!InstalledPkgs[@]}"; do
    [ "${PkgCategories[$id]}" = "_obsolete" ] && unset -v InstalledPkgs\["$id"\]
  done
## */
else
## read and parse <installed.db> file; populate ${InstalledPkgs[]}, ${PkgVersionInstalled[]} /*
  while read -r P F _ || [ "$P" ]; do
    V="${F#$P-}"; V="${V%.tar*}"

    id="${PkgID[$P]}"
    if ! [ "$id" ]; then
      add_new_package_to_catalogue "$P"
      ExtraneousPkgs[$MaxPkgID]="$P"
      id="$MaxPkgID"
    fi

    InstalledPkgs["$id"]="${PkgName[$id]}"
    PkgVersionInstalled["$id"]="$V"
  done < <(sed '1d; /^\s*$/d' "$installed_db")
## */
fi

echo "${#InstalledPkgs[@]}"

## print advance warning about extraneous installed packages /*
[ "$opt_be_more_quiet" ] ||
if [ "${#ExtraneousPkgs[@]}" -ne 0 ] && ! [ "$cmd_show_extraneous" ]; then
  echo >&2    "# $0:"
  echo >&2    "# warning: extraneous installed packages with unknown dependencies:"
  echo >&2    "#   the following installed packages are not present"
  echo >&2    "#   in Cygwin standard distribution:"
  echo >&2 -n "#("
  nout >&2 "${!ExtraneousPkgs[@]}"
  echo >&2    " )"
  echo >&2
fi
## */

## $cmd_show_extraneous /*
if [ "$cmd_show_extraneous" ]; then
  if [ "${#ExtraneousPkgs[@]}" -ne 0 ]; then
    for id in "${!ExtraneousPkgs[@]}"; do
      nout "$id"; echo ": extraneous installed package with unknown dependencies"
    done
    echo
  fi

  cmds="${cmds//$cmd_show_extraneous}"
  [ "$cmds" ] || exit
fi
## */

## $cmd_show_updates /*
if [ "$cmd_show_updates" ]; then
  T=''
  for id in "${!InstalledPkgs[@]}"; do
    [ "${ExtraneousPkgs[$id]}" ] && continue
    C="${PkgVersionInstalled[$id]}"
    V="${PkgVersionAvailable[$id]}"
    if [ "$V" ]; then
      if [ "$C" \< "$V" ]; then
        nout "$id"; echo "-$C: new version ( $V )"
        T="command output"
      fi
    else
      nout "$id"; echo "-$C: information about the new version is not available"
      T="command output"
    fi
  done
  [ "$T" ] && echo

  cmds="${cmds//$cmd_show_updates}"
  [ "$cmds" ] || exit
fi
## */

## convert name lists in ${ObsoletePkgs[]} to package ID lists /*
for id in "${!ObsoletePkgs[@]}"; do
  O="${ObsoletePkgs[$id]}"
  resolve_package_name_list O "$O" "in <setup.ini> file record of 'depends2:' for package ${PkgName[$id]}"
  ObsoletePkgs["$id"]="$O"
done
## */
## convert name lists in ${PkgObsoletedPkgs[]} to package ID lists, add obsoleted packages to ${ObsoletePkgs[]} /*
for id in "${!PkgObsoletedPkgs[@]}"; do
  O="${PkgObsoletedPkgs[$id]}"
  resolve_package_name_list O "$O" "in <setup.ini> file record of 'obsoletes:' for package ${PkgName[$id]}"
  PkgObsoletedPkgs["$id"]="$O"

  # add each obsoleted package and its replacement into ${ObsoletePkgs[]} if they are not there yet
  for P in $O; do
    R="${ObsoletePkgs[$P]}"
    if [ "$R" ]; then
      __find_in_list "$R" "$id" || ObsoletePkgs["$P"]+=$'\n'"$id"
    else
      ObsoletePkgs["$P"]="$id"
    fi
  done
done
## */

echo "${#ObsoletePkgs[@]}"

## determine requisites for installed packages /*
L="${!InstalledPkgs[*]}"
while [ "$L" ]; do
  C=''

  for id in $L; do
    # convert name lists in ${PkgRequisitesDeclared[$id]} to package ID lists
    R="${PkgRequisitesDeclared[$id]}"
    resolve_package_name_list R "$R" "in <setup.ini> file record of 'requires:' for package ${PkgName[$id]}"
    PkgRequisitesDeclared["$id"]="$R"

    # choose the appropriate list of requisites
    O="${ObsoletePkgs[$id]}"
    if [ "$O" ] && ! [ "$opt_respect_obsoleted" ]; then
      R="$O"
    else
      R="${PkgRequisitesDeclared[$id]}"
    fi

    # examine each package in the requisite list
    for P in $R; do
      O="${ObsoletePkgs[$P]}"
      if [ "$O" ] && ! [ "$opt_respect_obsoleted" ]; then
        PkgRequisites["$id"]+=$'\n'"$O"
      else
        PkgRequisites["$id"]+=$'\n'"$P"
      fi
    done

    # the resulting list
    PkgRequisites["$id"]="${PkgRequisites[$id]#$'\n'}"

    # detect broken dependencies
    filter_not_installed D "${PkgRequisites[$id]}"
    if [ "$D" ]; then
      PkgBrokenRequisites["$id"]="$D"
      for P in $D; do
        if [ "${MissingPkgs[$P]}" ]; then
          MissingPkgs["$P"]+=$'\n'"$id"
        else
          MissingPkgs["$P"]="$id"
          C+=" $P"
        fi
      done
    fi
  done

  L="$C"
done
## */

## print advance warning about unknown package names /*
[ "$opt_be_more_quiet" ] ||
if [ "${#UnknownPkgs[@]}" -ne 0 ] && ! [ "$cmd_show_unknown" ]; then
  echo >&2    "# $0:"
  echo >&2    "# warning: unknown package names:"
  echo >&2    "#   the following encountered package names does not match"
  echo >&2    "#   any available or installed package (use -M switch to get details):"
  echo >&2 -n "#("
  nout >&2 "${!UnknownPkgs[@]}"
  echo >&2    ")"
  echo >&2
fi
## */

## $cmd_show_unknown /*
if [ "$cmd_show_unknown" ]; then
  if [ "${#UnknownPkgs[@]}" -ne 0 ]; then
    for id in "${!UnknownPkgs[@]}"; do
      nout "$id"; echo -n ": unknown package name ${UnknownPkgs[$id]}"
    done
    echo
  fi

  cmds="${cmds//$cmd_show_unknown}"
  [ "$cmds" ] || exit
fi
## */

## $cmd_show_obsoleted /*
if [ "$cmd_show_obsoleted" ]; then
  T=''
  for id in "${!InstalledPkgs[@]}"; do
    O="${ObsoletePkgs[$id]}"
    if [ "$O" ]; then
      nout "$id"; echo -n ": is obsoleted by ("; nout "$O"; echo " )"
      T="command output"
    fi
  done
  [ "$T" ] && echo

  cmds="${cmds//$cmd_show_obsoleted}"
  [ "$cmds" ] || exit
fi
## */

## print advance warning about missing required dependencies /*
[ "$opt_be_more_quiet" ] ||
if [ "${#MissingPkgs[@]}" -ne 0 ] && ! [ "$cmd_show_missing" ]; then
  echo >&2    "# $0:"
  echo >&2    "# warning: missing required dependencies:"
  echo >&2    "#   the following packages are not installed, but are required as dependencies"
  echo >&2    "#   for some installed packages (use -m switch to get details):"
  echo >&2 -n "#("
  nout >&2 "${!MissingPkgs[@]}"
  echo >&2    " )"
  echo >&2
fi
## */

## $cmd_show_broken /*
if [ "$cmd_show_broken" ]; then
  if [ "${#PkgBrokenRequisites[@]}" -ne 0 ]; then
    for id in "${!PkgBrokenRequisites[@]}"; do
      nout "$id"; echo -n ": package with broken dependencies ("; nout "${PkgBrokenRequisites[$id]}"; echo " )"
    done
    echo
  fi

  cmds="${cmds//$cmd_show_broken}"
  [ "$cmds" ] || exit
fi
## */

## $cmd_show_missing /*
if [ "$cmd_show_missing" ]; then
  if [ "${#MissingPkgs[@]}" -ne 0 ]; then
    for id in "${!MissingPkgs[@]}"; do
      nout "$id"; echo -n ": missing required dependency for ("; nout "${MissingPkgs[$id]}"; echo " )"
    done
    echo
  fi

  cmds="${cmds//$cmd_show_missing}"
  [ "$cmds" ] || exit
fi
## */

## $cmd_show_islands, $cmd_show_interdependent /*
## */

if [ "$cmd_show_leaves" ] ||
   [ "$cmd_show_dependent" ] ||
   [ "$cmd_show_dependent_recursive" ] ||
   [ "$cmd_show_new_leaves" ] ||
   [ "$cmd_show_new_leaves_recursive" ]; then
## determine dependent packages for installed packages /*
  for id in "${!InstalledPkgs[@]}"; do
    R="${PkgRequisites[$id]}"
    for P in $R; do
      if [ "${PkgDependants[$P]}" ]; then
        PkgDependants["$P"]+=$'\n'"$id"
      else
        PkgDependants["$P"]="$id"
      fi
    done
  done
## */
fi

## $cmd_show_leaves /*
if [ "$cmd_show_leaves" ]; then
  T=''
  for id in "${!InstalledPkgs[@]}"; do
    if ! [ "${PkgDependants[$id]}" ]; then
      nout "$id"; __find_in_list "${PkgCategories[$id]}" "Base" && echo " [Base]" || echo
      T="command output"
    fi
  done
  [ "$T" ] && echo

  cmds="${cmds//$cmd_show_leaves}"
  [ "$cmds" ] || exit
fi
## */

queried_ids=''
resolve_package_name_list L "${*:$OPTIND}" "in command line arguments"
for id in $L; do
  if [ "${InstalledPkgs[$id]}" ]; then
    queried_ids+=" $id"
  else
    nout "$id"
    if [ "${UnknownPkgs[$id]}" ]; then
      echo ": unknown package name ${UnknownPkgs[$id]}"
    else
      echo ": package is not installed"
    fi
  fi
done
[ "$queried_ids" ] || exit

## $cmd_show_required, $cmd_show_dependent /*
if [ "$cmd_show_required" ] || [ "$cmd_show_dependent" ]; then
  for id in $queried_ids; do
    if [ "$cmd_show_required" ]; then
      R="${PkgRequisites[$id]}"
      nout "$id"; echo -n ": requires ("; nout "$R"; echo " )"
    fi
    if [ "$cmd_show_dependent" ]; then
      D="${PkgDependants[$id]}"
      nout "$id"; echo -n ": is needed for ("; nout "$D"; echo " )"
    fi
  done
  echo

  cmds="${cmds//$cmd_show_required}"
  cmds="${cmds//$cmd_show_dependent}"
  [ "$cmds" ] || exit
fi
## */

## $cmd_show_required_recursive, $cmd_show_dependent_recursive /*
if [ "$cmd_show_required_recursive" ] || [ "$cmd_show_dependent_recursive" ]; then
  for id in $queried_ids; do
    if [ "$cmd_show_required_recursive" ]; then
      R="${PkgRequisites_R[$id]-unset}"
      if [ "$R" = "unset" ]; then
        resolve_PkgRequisites_R "$id"
        R="${PkgRequisites_R[$id]}"
      fi
      nout "$id"; echo -n ": recursively requires ("; nout "$R"; echo " )"
    fi
    if [ "$cmd_show_dependent_recursive" ]; then
      D="${PkgDependants_R[$id]-unset}"
      if [ "$D" = "unset" ]; then
        resolve_PkgDependants_R "$id"
        D="${PkgDependants_R[$id]}"
      fi
      nout "$id"; echo -n ": is recursively needed for ("; nout "$D"; echo " )"
    fi
  done
  echo

  cmds="${cmds//$cmd_show_required_recursive}"
  cmds="${cmds//$cmd_show_dependent_recursive}"
  [ "$cmds" ] || exit
fi
## */

exit


####### declaring global variables /*
#######
declare L P R V F k n kk nn pp
declare -i i j ports0 extras0

# ${pkg_name[]} - an array of the all available package names, consists of the following three intervals:
#   [ 0 .. ports0 ) - cygwin distribution packages
#   [ ports0 .. extras0 ) - cygwin ports collection packages
#   [ extras0 ... ) - extra packages (installed packages not belonging to above distributions)
#   the index of a package name in this array defines an ID of the package

# ${pkg_index[]}, ${pkg_index_override[]} - associative arrays { name -> ID }, the inverse of the ${pkg_name[]}
# to fast determine the package ID by its name
# if there is another version of the package in the cygwin ports collection, the ${pkg_index_override[]} holds its second ID

# ${pkg_version[]} - an array of the versions of the available packages, it has the same structure as ${pkg_name[]}
# it is used in the case of opt_with_ports="yes" to determine which distribution the installed package is from

declare -a pkg_name
declare -A pkg_index pkg_index_override
declare -a pkg_version


# ${pkg_drequisites[]} - an array each element of which is a list of package IDs that are directly required by
#                        the package with an ID = element index
# ${pkg_ddependants[]} - an array each element of which is a list of package IDs that directly depend on
#                        the package with an ID = element index
# ${pkg_rrequisites[]} - an array each element of which is a full recursively resolved list of package IDs
#                        that are directly and indirectly required by the package with an ID = element index
# ${pkg_rdependants[]} - an array each element of which is a full recursively resolved list of package IDs
#                        that directly depend on the package with an ID = element index

declare -a pkg_drequisites pkg_ddependants
declare -a pkg_rrequisites pkg_rdependants

# pkg_installed[index] = index
declare -a pkg_installed pkg_version_installed
declare -a pkg_drequisites_discarded pkg_drequisites_phantom
declare extra_pkgs nonleaf_pkgs

declare chances_for_misleading warnings
####### */

####### reading off the setup.ini files; populating pkg_{name,index,version}, pkg_drequisites (preparatory) variables /*
#######
# $L - the input line
# $n - the number of the packages having been processed
# $id - the current package ID
# $P $C $R $V - temporary
P=''; C=''; R=''; V=''
L=''; let n=0; let id=0
while :; do
  while :; do
    case "$L" in
               @\ *) [ "$P" ] && break
                     P="${L#@ }"
                     ;;
       category:\ *) C="${L#category: }"
                     ;;
       requires:\ *) R="${L#requires: }"
                     ;;
        version:\ *) V="${L#version: }"
                     ;;
      obsoletes:\ *) O="${L#obsoletes: }"
    esac
    L=''
    IFS='' read -r L
    [ "$L" ] || break
  done
  if [ "$C" = "${C//_obsolete}" ]; then
    id=$n; let ++n
    pkg_name[$id]="$P"
    pkg_index["$P"]=$id
    pkg_drequisites[$id]="$R"
    pkg_version[$id]="$V"
  fi
  P=''; C=''; R=''; V=''
  [ "$L" ] || break
done < <(
          if [ "$opt_with_ports" ]; then
            sed -n '/^@ /p; /^category: /p; /^requires: /p; /^version: /p' "$cw_setup_ini"
          else
            sed -n '/^@ /p; /^category: /p; /^requires: /p' "$cw_setup_ini"
          fi
        )

ports0=${#pkg_name[@]}

if [ "$opt_with_ports" ]; then
  P=''; C=''; R=''; V=''
  L=''; let i=$ports0; let j=$ports0
  while IFS='' read -r L || [ "$L" ]; do
    case "$L" in
              @\ *) P="${L#@ }"
                    ;;
      category:\ *) C="${L#category: }"
                    ;;
      requires:\ *) R="${L#requires: }"
                    ;;
       version:\ *) V="${L#version: }"
                    ;;
    esac
    if [ "$C" = "${C//_obsolete}" ]; then
      j=$i; let ++i
      pkg_name[$j]="$P"
      k="${pkg_index[$P]}"
      [ "$k" ] && pkg_index_override["$P"]=$j || pkg_index["$P"]=$j
      pkg_version[$j]=""
      pkg_drequisites[$j]="$R"
      pkg_version[$j]="$V"
    fi
  done < <(sed -n '/^@ /p; /^category: /p; /^requires: /p; /^version: /p' "$cwp_setup_ini")
fi

extras0=${#pkg_name[@]}
####### */

####### reading off the installed.db file; adding to pkg_{name,index,drequisites} for extra packages; populating {pkg,pkg_version}_installed variables /*
#######
if [ "$opt_treat_all_packages" ]; then
  # treat all available packages being installed
  pkg_installed=(${!pkg_name[@]})
  
  let j=${#pkg_installed[@]}-1
  if [ $j -ne ${pkg_installed[$j]} ]; then
    echo >&2 "$0: internal error (12)"
    exit 12
  fi

  # if ports are used then prefer overridden versions of the packages
  [ "$opt_with_ports" ] && for P in "${!pkg_index_override[@]}"; do unset -v pkg_installed\[${pkg_index["$P"]}\]; done
else
  P=""; F=""; L=""
  i=$extras0
  while read -r P F L || [ "$P" ]; do
    if [ "$opt_with_ports" ]; then
      psfx="${F#$P-}"; pver="${psfx%-[0-9]*}"; prel="${psfx#$pver-}"; prel="${prel%%.*}"
      V="$pver-$prel"
    fi

    k="${pkg_index[$P]}"
    if ! [ "$k" ]; then  # extra package
      pkg_name[$i]="$P"
      pkg_index["$P"]=$i
      # [ "$opt_with_ports" ] && pkg_version[$i]="$V"
      pkg_drequisites[$i]=""

      pkg_installed[$i]=$i
      # [ "$opt_with_ports" ] && pkg_version_installed[$i]="$V"
      let ++i
      continue
    fi

    [ "$opt_with_ports" ] && n="${pkg_index_override[$P]}" || n=""
    if [ "$n" ]; then  # overridden package
      if [ "$V" == "${pkg_version[$k]}" ] && [ "${pkg_version[$k]}" = "${pkg_version[$n]}" ]; then
        pkg_drequisites[$k]="$(tr -s ' ' '\n' <<<"${pkg_drequisites[$k]}" | sort -u | tr '\n' ' ')"
        pkg_drequisites[$n]="$(tr -s ' ' '\n' <<<"${pkg_drequisites[$n]}" | sort -u | tr '\n' ' ')"
        if [ "${pkg_drequisites[$k]}" != "${pkg_drequisites[$n]}" ]; then
          if [ "$f_dependencies_be_necessary" ]; then
            echo "$0: WARNING: ambiguous installation source:"
            echo "$0:   unable to determine the installation source for"
            echo "$0:   the package '$P' which has the same versions"
            echo "$0:   in the Cygwin standard distribution and in the"
            echo "$0:   Cygwin Ports collection and the installed one;"
            echo "$0: $P: version installed=${V:-?} cygwin=${pkg_version[$k]:-#N/A} cygwinports=${pkg_version[$n]:-#N/A}"
            echo "$0:   lists of the package dependencies are different"
            echo "$0:   in the both sources:"
            echo "$0: $tag_cygwin$P: requires ( ${pkg_drequisites[$k]})"
            echo "$0: $tag_cygwinports$P: requires ( ${pkg_drequisites[$n]})"
            echo "$0:   the version from the Cygwin Ports collection"
            echo "$0:   will be preferred"
            chances_for_misleading="yes"
          fi
        fi
        j=$n
      else
        L="$(sort -V <<<"$V a"$'\n'"${pkg_version[$k]} c"$'\n'"${pkg_version[$n]} p" | sed -n 's/^.* //; H; ${ g; s/\n//gp; }')"
        let j=-1
        case "$L" in
          *ac*) j=$k;;
          *ap*) j=$n;;
            *a) L="${L: -2:1}"
                case "$L" in
                  c)  j=$k;;
                  p)  j=$n;;
                esac
                if [ "$f_dependencies_be_necessary" ]; then
                  echo       "$0: WARNING: unknown installed package version:"
                  echo       "$0:   unable to determine the installation source"
                  echo       "$0:   for the package '$P' which has overridden"
                  echo       "$0:   versions in the Cygwin standard distribution"
                  echo       "$0:   and in the Cygwin Ports collection and the"
                  echo       "$0:   installed version greater than in the both"
                  echo       "$0:   installation sources;"
                  echo       "$0: $P: version installed=${V:-?} cygwin=${pkg_version[$k]:-#N/A} cygwinports=${pkg_version[$n]:-#N/A}"
                  echo       "$0:   dependencies for this package will be taken"
                  echo       "$0:   from the source with the nearest package version"
                  echo -n    "$0:   number: "
                  case "$L" in
                    c)  echo "Cygwin standard distribution";;
                    p)  echo "Cygwin Ports collection (preferred)";;
                  esac
                  chances_for_misleading="yes"
                fi
                ;;
        esac
      fi
      pkg_installed[$j]=$j
      pkg_version_installed[$j]="$V"
    else
      pkg_installed[$k]=$k
      # [ "$opt_with_ports" ] && pkg_version_installed[$k]="$V"
    fi
  done < <(sed '1d' "$installed_db")
fi
####### */

####### nout() /*
#######
nout()
{ # function to print package name by its ID; the name is optionally prefixed by a distribution tag and markers
  local pp

  if [ $# -gt 1 ]; then
    local k
    local -a t

    # fast sorting and deduplicating
    for k; do [ "$k" ] && t["$k"]="$k"; done

    for k in ${!t[@]}; do
      if [ "$opt_print_src_tag" ]; then
        [ $k -lt $ports0 ] && pp="$tag_cygwin" || { [ $k -lt $extras0 ] && pp="$tag_cygwinports" || pp="$tag_extra"; }
      else
        pp=""
      fi
      [ "$k" -ge $extras0 ] && pp="${pp}?"
      [ "${pkg_drequisites_discarded[$k]}" ] && pp="${pp}*"
      #[ "${pkg_drequisites_phantom[$k]}" ] && pp="${pp}!"
      echo -n " ${pp}${pkg_name[$k]}"
    done
  else
    [ "$1" ] || return

    if [ "$opt_print_src_tag" ]; then
      [ "$1" -lt $ports0 ] && pp="$tag_cygwin" || { [ "$1" -lt $extras0 ] && pp="$tag_cygwinports" || pp="$tag_extra"; }
    else
      pp=""
    fi
    [ "$1" -ge $extras0 ] && pp="${pp}?"
    [ "${pkg_drequisites_discarded[$1]}" ] && pp="${pp}*"
    #[ "${pkg_drequisites_phantom[$1]}" ] && pp="${pp}!"
    echo -n " ${pp}${pkg_name[$1]}"
  fi
}
####### */

####### resolving necessary pkg_drequisites and nonleaf_pkgs /*
if [ "$f_dependencies_be_necessary" ]; then
  # for each installed package check and substitute
  # package names with the appropriate package IDs in the list of the package direct dependencies
  for i in ${!pkg_name[@]}; do
    # skip the package if it is not installed; also clear its list of directly required packages
    if ! [ "${pkg_installed[$i]}" ]; then
      unset -v pkg_drequisites\[$i\]
      continue
    fi

    R="${pkg_drequisites[$i]}"
    pkg_drequisites[$i]=""

    # $R - the list of names
    # $L - the resulting list of IDs instead of names
    # $F - phantom dependencies
    # $V - broken dependencies
    L=""; F=""; V=""
    for P in $R; do
      # get the package ID ($k) by its name ($P)
      k="${pkg_index[$P]}"
      # if failed then this is a phantom name
      if ! [ "$k" ]; then
        F="$F $P"
        continue
      fi

      # $k must be a package ID that is installed; check for this;
      kk=$k; nn=$k

      [ "$opt_with_ports" ] && n="${pkg_index_override[$P]}" || n=""
      # there may be an overridden package from the ports; check for this an for which of the IDs is installed
      if [ "$n" ]; then
        nn=$n
        k=${pkg_installed[$k]}
        n=${pkg_installed[$n]}
        if [ "$k" ] && [ "$n" ]; then
          echo >&2 "$0: internal error (13)"
          exit 13
        fi
        if [ "$opt_treat_all_packages" ] && { [ ! "$k" ] && [ ! "$n" ]; }; then
          echo >&2 "$0: internal error (14)"
          exit 14
        fi
        # OK, there is either $k or $n; put the result into $k
        [ "$n" ] && k=$n
      else
        k=${pkg_installed[$k]}
      fi

      # if the package is installed ($k is non empty) add it to the resulting list ($L)
      # or else put it into broken dependency list ($V);
      # in the latter case if an overridden package from the ports is also available use
      # the ID from the same distribution as the package from which dependency list it is from
      [ "$k" ] && L="$L"$'\n'$k || { [ $i -lt $ports0 ] && V="$V $kk" || V="$V $nn"; }
    done

    if [ "$F" ]; then
      pkg_drequisites_phantom[$i]="$F"
      if [ ! "$opt_suppress_unneeded_warns" ] && [ ! "$opt_show_phantom" ]; then
        [ $i -lt $ports0 ] && pp="$tag_cygwin" || { [ $i -lt $extras0 ] && pp="$tag_cygwinports" || pp="$tag_extra"; }
        echo "$0: WARNING: phantom dependencies:"
        echo "$0:   installed package '${pp}${pkg_name[$i]}'"
        echo "$0:   requires the following phantom dependencies"
        echo "$0:   (nonpresent packages likely renamed/retired/etc.)"
        echo "$0: ($F )"
        warnings="yes"
      fi
    fi

    pkg_drequisites[$i]="$L"

    if [ "$V" ]; then
      pkg_drequisites_discarded[$i]="$V"
      if [ ! "$opt_suppress_unneeded_warns" ] && [ ! "$opt_show_broken" ]; then
        [ $i -lt $ports0 ] && pp="$tag_cygwin" || { [ $i -lt $extras0 ] && pp="$tag_cygwinports" || pp="$tag_extra"; }
        echo    "$0: WARNING: broken dependencies:"
        echo    "$0:   installed package '${pp}${pkg_name[$i]}'"
        echo    "$0:   depends on the following required packages that are"
        echo    "$0:   not installed; these dependencies will be discarded"
        echo -n "$0: ("; nout $V; echo " )"
        chances_for_misleading="yes"
      fi
    fi
  done
fi

if [ "$f_nonleaves_be_necessary" ]; then
  # build the list of nonleaves packages sorted from more often required packages to less ones
  nonleaf_pkgs="$(IFS=$'\n'; sort -n <<<"${pkg_drequisites[*]}" | sed '/^$/d' | uniq -c | sort -nr | sed 's/^\s\+[0-9]\+\s\+//')"
fi
####### */

####### printing out the warning about extra packages /*
#######
if ! [ "$opt_treat_all_packages" ]; then
  extra_pkgs="${pkg_installed[*]:$extras0}"
  if [ "$extra_pkgs" ] && [ ! "$opt_suppress_unneeded_warns" ]; then
    echo    "$0: WARNING: extra packages with unknown dependencies:"
    echo    "$0:   the following installed packages are not"
    if [ "$opt_with_ports" ]; then
      echo  "$0:   present in the Cygwin standard distribution"
      echo  "$0:   or in the Cygwin Ports collection;"
    else
      echo  "$0:   present in the Cygwin standard distribution;"
    fi
    echo    "$0:   these packages will be prefixed with a question mark (?)"
    echo -n "$0: ("
    for i in $extra_pkgs; do echo -n " ${pkg_name[$i]}"; done
    echo " )"
    [ "$f_dependencies_be_necessary" ] && chances_for_misleading="yes" || warnings="yes"
  fi
fi
####### */

####### printing out the warning about misleading results and/or '\n' if there are warnings printed out /*
#######
if [ "$chances_for_misleading" ]; then
      echo    "$0: WARNING: possible misleading results:"
      echo    "$0:   due to reasons of the above warning(s) the results"
      echo -n "$0:   of dependency resolution may appear to be misleading"
    if [ ${#pkg_drequisites_discarded[@]} -gt 0 ]; then
      echo ";"
      echo    "$0:   packages with discarded broken dependencies"
      echo    "$0:   will be prefixed with an asterisk (*)"
    else
      echo
    fi
fi
{ [ "$chances_for_misleading" ] || [ "$warnings" ]; } && echo
####### */

####### processing for opt_show_overridden /*
#######
if [ "$opt_show_overridden" ]; then
  for P in "${!pkg_index_override[@]}"; do
    k=${pkg_index["$P"]}
    n=${pkg_index_override["$P"]}
    [ "${pkg_installed[$k]}" ] && echo " $P: version installed=${pkg_version_installed[$k]:-?} cygwin=${pkg_version[$k]:-#N/A} cygwinports=${pkg_version[$n]:-#N/A}"
    [ "${pkg_installed[$n]}" ] && echo " $P: version installed=${pkg_version_installed[$n]:-?} cygwin=${pkg_version[$k]:-#N/A} cygwinports=${pkg_version[$n]:-#N/A}"
  done | sort
fi
####### */

####### processing for opt_show_phantom /*
if [ "$opt_show_phantom" ]; then
  for i in ${!pkg_drequisites_phantom[@]}; do
    nout $i; echo ": requires the phantom packages (${pkg_drequisites_phantom[$i]} )"
  done
fi
####### */

####### processing for opt_show_broken /*
if [ "$opt_show_broken" ]; then
  for i in ${!pkg_drequisites_discarded[@]}; do
    nout $i; echo -n ": broken required dependencies ("; nout ${pkg_drequisites_discarded[$i]}; echo " )"
  done
  for i in $extra_pkgs; do
    nout $i; echo ": extra package with unknown dependencies"
  done
fi
####### */

####### processing for opt_show_leaves /*
#######
if [ "$opt_show_leaves" ]; then
  ( # this is a subshell
    for i in $nonleaf_pkgs; do unset -v pkg_installed\[$i\]; done
    for j in ${!pkg_installed[@]}; do nout $j; echo; done
  )
fi
####### */

####### rrequisites_add(), rrequisites_resolve() /*
#######
rrequisites_add()
{
  local -i t="$1"
  local p k
  local -a r

  # fast sorting and deduplicating
  for p in ${pkg_rrequisites[$1]}; do r["$p"]="$p"; done

  #while shift; [ $# -gt 0 ]; do r["$1"]="$1"; done
  shift; for k; do r["$k"]="$k"; done

  pkg_rrequisites[$t]="${!r[*]}"
}

rrequisites_resolve()
{
  # using the array as an internal data structure helps to keep the list by itself sorted and w/o duplicated records
  local -a pp

  rr()
  {
    local p e

    for p in ${pkg_drequisites["$1"]}; do
      # if the ID ($p) is already in the list, skip it
      if ! test "${pp[$p]}"; then
        pp["$p"]="$p"
        # if ${pkg_rrequisites[$p]} is set (i.e. already resolved, which also may be an empty value), take it
        if [ "${pkg_rrequisites[$p]+set}" ]; then
          for e in ${pkg_rrequisites[$p]}; do pp["$e"]="$e"; done
        else
          rr "$p"
        fi
      fi
    done
  }

  if ! test "${pkg_rrequisites[$1]+set}"; then
    rr "$1"
    pkg_rrequisites["$1"]="${!pp[*]}"
  fi
}
####### */

####### processing for opt_show_islands, opt_show_interdependent /*
#######
if [ "$opt_show_islands" ] || [ "$opt_show_interdependent" ]; then
  # $nonleaf packages are most frequently required packages,
  # so at first resolve their $pkg_rrequisites to speed up resolving
  # $pkg_rrequisites for the remain packages
  for i in $nonleaf_pkgs; do
    rrequisites_resolve $i
  done
  for i in ${!pkg_installed[@]}; do
    rrequisites_resolve $i
  done

  L=""
  while IFS='' read -r -d $'\x00' L || [ "$L" ]; do
    if [ "$opt_show_islands" ]; then
      # finding out if an interdependent group ($L) is an "island"
      for P in $L; do
        # skip the group ($L) if it has a package ($P) that required by the package ($i) not belonging to the group ($L)
        # so the interdependent group ($L) is not a leaf (is not an "island")
        for i in ${!pkg_installed[@]}; do
          [[ "${pkg_drequisites[$i]}" =~ (^|$'\n')"$P"($'\n'|$) ]] && { [[ "$L" =~ (^|$'\n')$i($'\n'|$) ]] || continue 3; }
        done
      done
    fi
    echo -n "("; nout $L; echo " )"
  done <\
  <( # this is a subshell
     # finding out groups of interdependent packages;
     # packages building up an interdependent group have the same $pkg_rrequisites lists
     # and themselves belongs to their own $pkg_rrequisites list;
     # adding package ID to its $pkg_rrequisites list helps to filter out packages that have the same
     # pkg_rrequisites list as packages in an interdependent group but that are not part of the group
    for i in ${!pkg_installed[@]}; do
      rrequisites_add $i $i
      echo "$i ${pkg_rrequisites[$i]}"
      # sort -k 2  # skip the leading package ID, sort by the $pkg_rrequisites list
      # uniq -f 1 --all-repeated=separate  # skip the leading package ID, separate duplicates by a blank line
      # sed 's/ .*$//; s/^$/\x00/'  # leave only the package IDs, treat blank lines as a group null-terminator
    done | sort -k 2 | uniq -f 1 --all-repeated=separate | sed 's/ .*$//; s/^$/\x00/'
   )
fi
####### */

####### ddependants_prep(), rdependants_resolve() /*
#######
ddependants_prep()
{ # function to build the '\n'-separated list of the packages (${pkg_ddependants[$1]})
  # that directly require (i.e. directly depend on) the package ($1)
  test "${pkg_ddependants[$1]+set}" && return

  local d

  pkg_ddependants["$1"]=""
  for d in ${!pkg_installed[@]}; do
    [[ "${pkg_drequisites[$d]}" =~ (^|$'\n')"$1"($'\n'|$) ]] && pkg_ddependants["$1"]="${pkg_ddependants[$1]}"$'\n'$d
  done
}

rdependants_resolve()
{
  # using the array as an internal data structure helps to get the resulting list automatically sorted and deduplicated
  local -a pp

  rr()
  {
    local p e

    ddependants_prep "$1"
    for p in ${pkg_ddependants["$1"]}; do
      # if the ID ($p) is already in the list, do not process it
      if ! test "${pp[$p]}"; then
        pp["$p"]="$p"
        # if ${pkg_rdependants[$p]} is set (i.e. already resolved, which also may be an empty value), take it
        if [ "${pkg_rdependants[$p]+set}" ]; then
          for e in ${pkg_rdependants[$p]}; do pp["$e"]="$e"; done
        else
          rr "$p"
        fi
      fi
    done
  }

  if ! test "${pkg_rdependants[$1]+set}"; then
    rr "$1"
    pkg_rdependants["$1"]="${!pp[*]}"
  fi
}
####### */

####### processing for opt_show_required, opt_resolve_required, opt_show_dependent, opt_resolve_dependent /*
#######
if [ "$opt_show_required" ] || [ "$opt_resolve_required" ] || [ "$opt_show_dependent" ] || [ "$opt_resolve_dependent" ]; then
  for P in "${@:$OPTIND}"; do
    # get the package ID ($k) by its name ($P)
    k=${pkg_index["$P"]}
    if [ "$k" ]; then
      [ "$opt_with_ports" ] && n="${pkg_index_override[$P]}" || n=""
      # it may be overridden by the package from the ports; which of the IDs is installed?
      if [ "$n" ]; then
        k=${pkg_installed[$k]}
        n=${pkg_installed[$n]}
        if [ "$k" ] && [ "$n" ]; then
          echo >&2 "$0: internal error (13)"
          exit 13
        fi
        if [ "$opt_treat_all_packages" ] && { [ ! "$k" ] && [ ! "$n" ]; }; then
          echo >&2 "$0: internal error (14)"
          exit 14
        fi
        # OK, there is either $k or $n; put the result into $k
        [ "$n" ] && k=$n
      else
        k=${pkg_installed[$k]}
      fi
      if ! [ "$k" ]; then
        echo " $P: package is not installed"
        continue
      fi
    else
      echo " $P: package does not exist"
      continue
    fi

    if [ "$opt_show_required" ]; then
      nout $k; echo -n ": requires ("; nout ${pkg_drequisites[$k]}; echo " )"
    fi

    if [ "$opt_resolve_required" ]; then
      rrequisites_resolve $k
      nout $k; echo -n ": recursively requires ("; nout ${pkg_rrequisites[$k]}; echo " )"
    fi

    if [ "$opt_show_dependent" ]; then
      ddependants_prep $k
      nout $k; echo -n ": is needed for ("; nout ${pkg_ddependants[$k]}; echo " )"
    fi

    if [ "$opt_resolve_dependent" ]; then
      rdependants_resolve $k
      nout $k; echo -n ": is recursively needed for ("; nout ${pkg_rdependants[$k]}; echo " )"
    fi
  done
fi
####### */


# vim: et ts=2 sw=2 sts=0
# vim: fdc=4 fdl=0 fdm=marker fmr=/*,*/
